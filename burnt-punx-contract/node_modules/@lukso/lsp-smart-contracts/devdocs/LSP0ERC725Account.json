{
  "author": "Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42)",
  "details": "A smart contract account including basic functionalities such as: - Detecting supported standards using [ERC-165] - Executing several operation on other addresses including creating contracts using [ERC-725X] - A generic data key-value store using [ERC-725Y] - Validating signatures using [ERC-1271] - Receiving notification and react on them using [LSP-1-UniversalReceiver] - Safer ownership management through 2-steps transfer using [LSP-14-Ownable2Step] - Extending the account with new functions and interfaceIds of future standards using [LSP-17-ContractExtension] - Verifying calls on the owner to make it easier to interact with the account directly using [LSP-20-CallVerification]",
  "errors": {
    "ERC725X_ContractDeploymentFailed()": [
      {
        "details": "Reverts when contract deployment failed via {execute} or {executeBatch} functions, This error can occur using either operation type 1 (`CREATE`) or 2 (`CREATE2`)."
      }
    ],
    "ERC725X_CreateOperationsRequireEmptyRecipientAddress()": [
      {
        "details": "Reverts when passing a `to` address that is not `address(0)` (= address zero) while deploying a contract via {execute} or {executeBatch} functions. This error can occur using either operation type 1 (`CREATE`) or 2 (`CREATE2`)."
      }
    ],
    "ERC725X_ExecuteParametersEmptyArray()": [
      {
        "details": "Reverts when one of the array parameter provided to the {executeBatch} function is an empty array."
      }
    ],
    "ERC725X_ExecuteParametersLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `operationTypes`, `targets` addresses, `values`, and `datas` array parameters provided when calling the {executeBatch} function."
      }
    ],
    "ERC725X_InsufficientBalance(uint256,uint256)": [
      {
        "details": "Reverts when trying to send more native tokens `value` than available in current `balance`.",
        "params": {
          "balance": "The balance of native tokens of the ERC725X smart contract.",
          "value": "The amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` that is greater than the contract's `balance`."
        }
      }
    ],
    "ERC725X_MsgValueDisallowedInDelegateCall()": [
      {
        "details": "Reverts when trying to send native tokens (`value` / `values[]` parameter of {execute} or {executeBatch} functions) while making a `delegatecall` (`operationType == 4`). Sending native tokens via `staticcall` is not allowed because `msg.value` is persisting."
      }
    ],
    "ERC725X_MsgValueDisallowedInStaticCall()": [
      {
        "details": "Reverts when trying to send native tokens (`value` / `values[]` parameter of {execute} or {executeBatch} functions) while making a `staticcall` (`operationType == 3`). Sending native tokens via `staticcall` is not allowed because it is a state changing operation."
      }
    ],
    "ERC725X_NoContractBytecodeProvided()": [
      {
        "details": "Reverts when no contract bytecode was provided as parameter when trying to deploy a contract via {execute} or {executeBatch}. This error can occur using either operation type 1 (`CREATE`) or 2 (`CREATE2`)."
      }
    ],
    "ERC725X_UnknownOperationType(uint256)": [
      {
        "details": "Reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        "params": {
          "operationTypeProvided": "The unrecognised operation type number provided to `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`."
        }
      }
    ],
    "ERC725Y_DataKeysValuesEmptyArray()": [
      {
        "details": "Reverts when one of the array parameter provided to {setDataBatch} function is an empty array."
      }
    ],
    "ERC725Y_DataKeysValuesLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `datakeys` and `dataValues` array parameters provided when calling the {setDataBatch} function."
      }
    ],
    "LSP14CallerNotPendingOwner(address)": [
      {
        "details": "Reverts when the `caller` that is trying to accept ownership of the contract is not the pending owner.",
        "params": {
          "caller": "The address that tried to accept ownership."
        }
      }
    ],
    "LSP14CannotTransferOwnershipToSelf()": [
      {
        "details": "Reverts when trying to transfer ownership to the `address(this)`."
      }
    ],
    "LSP14MustAcceptOwnershipInSeparateTransaction()": [
      {
        "details": "Reverts when pending owner accept ownership in the same transaction of transferring ownership."
      }
    ],
    "LSP14NotInRenounceOwnershipInterval(uint256,uint256)": [
      {
        "details": "Reverts when trying to renounce ownership before the initial confirmation delay.",
        "params": {
          "renounceOwnershipEnd": "The end timestamp when one can confirm the renouncement of ownership.",
          "renounceOwnershipStart": "The start timestamp when one can confirm the renouncement of ownership."
        }
      }
    ],
    "LSP20CallVerificationFailed(bool,bytes4)": [
      {
        "details": "reverts when the call to the owner does not return the LSP20 success value",
        "params": {
          "postCall": "True if the execution call was done, False otherwise",
          "returnedStatus": "The bytes4 decoded data returned by the logic verifier."
        }
      }
    ],
    "LSP20CallingVerifierFailed(bool)": [
      {
        "details": "reverts when the call to the owner fail with no revert reason",
        "params": {
          "postCall": "True if the execution call was done, False otherwise"
        }
      }
    ],
    "LSP20EOACannotVerifyCall(address)": [
      {
        "details": "Reverts when the logic verifier is an Externally Owned Account (EOA) that cannot return the LSP20 success value.",
        "params": {
          "logicVerifier": "The address of the logic verifier"
        }
      }
    ],
    "NoExtensionFoundForFunctionSelector(bytes4)": [
      {
        "details": "reverts when there is no extension for the function selector being called with"
      }
    ]
  },
  "kind": "dev",
  "methods": {
    "acceptOwnership()": {
      "custom:requirements": "- Only the {pendingOwner} can call this function. - When notifying the previous owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_SenderNotification]. - When notifying the new owner via LSP1, the typeId used must be the `keccak256(...)` hash of [LSP0OwnershipTransferred_RecipientNotification].",
      "details": "Transfer ownership of the contract from the current {owner()} to the {pendingOwner()}. Once this function is called: - The current {owner()} will lose access to the functions restricted to the {owner()} only. - The {pendingOwner()} will gain access to the functions restricted to the {owner()} only."
    },
    "batchCalls(bytes[])": {
      "custom:info": "It's not possible to send value along the functions call due to the use of `delegatecall`.",
      "details": "Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",
      "params": {
        "data": "An array of ABI encoded function calls to be called on the contract."
      },
      "returns": {
        "results": "An array of abi-encoded data returned by the functions executed."
      }
    },
    "constructor": {
      "custom:events": "- {UniversalReceiver} event when funding the contract on deployment. - {OwnershipTransferred} event when `initialOwner` is set as the contract {owner}.",
      "details": "Set `initialOwner` as the contract owner. - The `constructor` also allows funding the contract on deployment. - The `initialOwner` will then be allowed to call protected functions marked with the `onlyOwner` modifier.",
      "params": {
        "initialOwner": "The owner of the contract."
      }
    },
    "execute(uint256,address,uint256,bytes)": {
      "custom:events": "- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2). - {UniversalReceiver} event when receiving native tokens.",
      "custom:requirements": "- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",
      "details": "Generic executor function to: - send native tokens to any address. - interact with any contract by passing an abi-encoded function call in the `data` parameter. - deploy a contract by providing its creation bytecode in the `data` parameter.",
      "params": {
        "data": "The call data, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",
        "operationType": "The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
        "target": "The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)",
        "value": "The amount of native tokens to transfer (in Wei)"
      }
    },
    "executeBatch(uint256[],address[],uint256[],bytes[])": {
      "custom:events": "- {Executed} event for each call that uses under `operationType`: `CALL` (0), `STATICCALL` (3) and `DELEGATECALL` (4). (each iteration) - {ContractCreated} event, when a contract is created under `operationType`: `CREATE` (1) and `CREATE2` (2) (each iteration) - {UniversalReceiver} event when receiving native tokens.",
      "custom:requirements": "- The length of the parameters provided must be equal. - Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - If a `value` is provided, the contract must have at least this amount in its balance to execute successfully. - If the operation type is `CREATE` (1) or `CREATE2` (2), `target` must be `address(0)`. - If the operation type is `STATICCALL` (3) or `DELEGATECALL` (4), `value` transfer is disallowed and must be 0.",
      "custom:warning": "- The `msg.value` should not be trusted for any method called within the batch with `operationType`: `DELEGATECALL` (4).",
      "details": "Batch executor function that behaves the same as {execute} but allowing multiple operations in the same transaction.",
      "params": {
        "datas": "The list of calldata, or the creation bytecode of the contract to deploy if `operationType` is `1` or `2`.",
        "operationsType": "The list of operations type used: `CALL = 0`; `CREATE = 1`; `CREATE2 = 2`; `STATICCALL = 3`; `DELEGATECALL = 4`",
        "targets": "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
        "values": "The list of native token amounts to transfer (in Wei)."
      }
    },
    "getData(bytes32)": {
      "details": "Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",
      "params": {
        "dataKey": "The data key for which to retrieve the value."
      },
      "returns": {
        "dataValue": "The bytes value stored under the specified data key."
      }
    },
    "getDataBatch(bytes32[])": {
      "details": "Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",
      "params": {
        "dataKeys": "The array of keys which values to retrieve"
      },
      "returns": {
        "dataValues": "The array of data stored at multiple keys"
      }
    },
    "isValidSignature(bytes32,bytes)": {
      "custom:warning": "This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP0ERC725Account and prevent signatures from the same EOA to be replayed across different LSP0ERC725Accounts.",
      "details": "Handles two cases: 1. If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the `_ERC1271_SUCCESSVALUE` if the address recovered is the same as the owner, indicating that it was a valid signature.      - If the address is different, it returns the `_ERC1271_FAILVALUE` indicating that the signature is not valid. 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:      - If the contract fails or returns the `_ERC1271_FAILVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_FAILVALUE`, indicating that the signature is not valid.      - If the {isValidSignature()} on the owner returned the `_ERC1271_SUCCESSVALUE`, the {isValidSignature()} on the account returns the `_ERC1271_SUCCESSVALUE`, indicating that it's a valid signature.",
      "params": {
        "dataHash": "The hash of the data to be validated.",
        "signature": "A signature that can validate the previous parameter (Hash)."
      },
      "returns": {
        "returnedStatus": "A `bytes4` value that indicates if the signature is valid or not."
      }
    },
    "owner()": {
      "details": "Returns the address of the current owner."
    },
    "pendingOwner()": {
      "custom:info": "If no ownership transfer is in progress, the pendingOwner will be `address(0).`.",
      "details": "The address that ownership of the contract is transferred to. This address may use {acceptOwnership()} to gain ownership of the contract."
    },
    "renounceOwnership()": {
      "custom:danger": "Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner or an address allowed by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      "custom:requirements": "Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",
      "details": "Renounce ownership of the contract in a 2-step process. 1. The first call will initiate the process of renouncing ownership. 2. The second call is used as a confirmation and will leave the contract without an owner."
    },
    "setData(bytes32,bytes)": {
      "custom:events": "- {UniversalReceiver} event when receiving native tokens. - {DataChanged} event.",
      "custom:requirements": "Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",
      "details": "Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",
      "params": {
        "dataKey": "The data key for which to set a new value.",
        "dataValue": "The new bytes value to set."
      }
    },
    "setDataBatch(bytes32[],bytes[])": {
      "custom:events": "- {UniversalReceiver} event when receiving native tokens. - {DataChanged} event. (on each iteration of setting data)",
      "custom:requirements": "Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner.",
      "details": "Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",
      "params": {
        "dataKeys": "An array of data keys to set bytes values for.",
        "dataValues": "An array of bytes values to set for each `dataKeys`."
      }
    },
    "supportsInterface(bytes4)": {
      "details": "Achieves the goal of [ERC-165] to detect supported interfaces and [LSP-17-ContractExtension] by checking if the interfaceId being queried is supported on another linked extension. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to [LSP-17-ContractExtension], and checks if the extension implements the interface defined by `interfaceId`.",
      "params": {
        "interfaceId": "The interface ID to check if the contract supports it."
      },
      "returns": {
        "_0": "`true` if this contract implements the interface defined by `interfaceId`, `false` otherwise."
      }
    },
    "transferOwnership(address)": {
      "custom:requirements": "- Can be only called by the {owner} or by an authorised address that pass the verification check performed on the owner. - When notifying the new owner via LSP1, the `typeId` used must be the `keccak256(...)` hash of [LSP0OwnershipTransferStarted]. - Pending owner cannot accept ownership in the same tx via the LSP1 hook.",
      "details": "Initiate the process of transferring ownership of the contract by setting the new owner as the pending owner. If the new owner is a contract that supports + implements LSP1, this will also attempt to notify the new owner that ownership has been transferred to them by calling the {universalReceiver()} function on the `newOwner` contract.",
      "params": {
        "newOwner": "The address of the new owner."
      }
    },
    "universalReceiver(bytes32,bytes)": {
      "custom:events": "- {UniversalReceiver} when receiving native tokens. - {UniversalReceiver} event with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract that was called.",
      "details": "Achieves the goal of [LSP-1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts ([LSP1UniversalReceiverDelegate]) that react on the whole transaction and on the specific typeId, respectively. The function performs the following steps: 1. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY].      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. 2. Query the [ERC-725Y] storage with the data key [_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX] + `bytes32(typeId)`.   (Check [LSP-2-ERC725YJSONSchema] for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function. This function delegates internally the handling of native tokens to the {universalReceiver} function itself passing `_TYPEID_LSP0_VALUE_RECEIVED` as typeId and the calldata as received data.",
      "params": {
        "receivedData": "The data received.",
        "typeId": "The type of call received."
      },
      "returns": {
        "returnedValues": "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call."
      }
    }
  },
  "title": "Deployable Implementation of [LSP-0-ERC725Account] Standard.",
  "version": 1
}