{
  "author": "Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)",
  "details": "All the permissions can be set on the ERC725 Account using `setData(bytes32,bytes)` or `setData(bytes32[],bytes[])`.",
  "errors": {
    "BatchExecuteParamsLengthMismatch()": [
      {
        "details": "Reverts when the array parameters `uint256[] value` and `bytes[] payload` have different sizes. There should be the same number of elements for each array parameters."
      }
    ],
    "BatchExecuteRelayCallParamsLengthMismatch()": [
      {
        "details": "Reverts when providing array parameters of different sizes to `executeRelayCallBatch(bytes[],uint256[],bytes[])`"
      }
    ],
    "CallingKeyManagerNotAllowed()": [
      {
        "details": "Reverts when calling the KeyManager through `execute(uint256,address,uint256,bytes)`."
      }
    ],
    "DelegateCallDisallowedViaKeyManager()": [
      {
        "details": "Reverts when trying to do a `delegatecall` via the ERC725X.execute(uint256,address,uint256,bytes) (operation type 4) function of the linked {target}. `DELEGATECALL` is disallowed by default on the LSP6KeyManager."
      }
    ],
    "ERC725X_ExecuteParametersEmptyArray()": [
      {
        "details": "Reverts when one of the array parameter provided to the {executeBatch} function is an empty array."
      }
    ],
    "ERC725X_ExecuteParametersLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `operationTypes`, `targets` addresses, `values`, and `datas` array parameters provided when calling the {executeBatch} function."
      }
    ],
    "ERC725Y_DataKeysValuesLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `datakeys` and `dataValues` array parameters provided when calling the {setDataBatch} function."
      }
    ],
    "InvalidDataValuesForDataKeys(bytes32,bytes)": [
      {
        "details": "Reverts when the data value length is not one of the required lengths for the specific data key.",
        "params": {
          "dataKey": "The data key that has a required length for the data value.",
          "dataValue": "The data value that has an invalid length."
        }
      }
    ],
    "InvalidERC725Function(bytes4)": [
      {
        "details": "Reverts when trying to call a function on the linked {target}, that is not any of the following: - `setData(bytes32,bytes)` (ERC725Y) - `setDataBatch(bytes32[],bytes[])` (ERC725Y) - `execute(uint256,address,uint256,bytes)` (ERC725X) - `transferOwnership(address)` (LSP14) - `acceptOwnership()` (LSP14) - `renounceOwnership()` (LSP14)",
        "params": {
          "invalidFunction": "The `bytes4` selector of the function that was attempted to be called on the linked {target} but not recognised."
        }
      }
    ],
    "InvalidEncodedAllowedCalls(bytes)": [
      {
        "details": "Reverts when `allowedCallsValue` is not properly encoded as a `(bytes4,address,bytes4,bytes4)[CompactBytesArray]` (CompactBytesArray made of tuples that are 32 bytes long each). See LSP2 value type `CompactBytesArray` for more infos.",
        "params": {
          "allowedCallsValue": "The list of allowedCalls that are not encoded correctly as a `(bytes4,address,bytes4,bytes4)[CompactBytesArray]`."
        }
      }
    ],
    "InvalidEncodedAllowedERC725YDataKeys(bytes,string)": [
      {
        "details": "Reverts when `value` is not encoded properly as a `bytes32[CompactBytesArray]`. The `context` string provides context on when this error occurred (_e.g: when fetching the `AllowedERC725YDataKeys` to verify the permissions of a controller, or when validating the `AllowedERC725YDataKeys` when setting them for a controller).",
        "params": {
          "context": "A brief description of where the error occurred.",
          "value": "The value that is not a valid `bytes32[CompactBytesArray]`"
        }
      }
    ],
    "InvalidLSP6Target()": [
      {
        "details": "Reverts when the address provided to set as the {target} linked to this KeyManager is invalid (_e.g. `address(0)`_)."
      }
    ],
    "InvalidPayload(bytes)": [
      {
        "details": "Reverts when the payload is invalid."
      }
    ],
    "InvalidRelayNonce(address,uint256,bytes)": [
      {
        "details": "Reverts when the `signer` address retrieved from the `signature` has an invalid nonce: `invalidNonce`.",
        "params": {
          "invalidNonce": "The nonce retrieved for the `signer` address.",
          "signature": "The signature used to retrieve the `signer` address.",
          "signer": "The address of the signer."
        }
      }
    ],
    "InvalidWhitelistedCall(address)": [
      {
        "details": "Reverts when a `from` address has _\"any whitelisted call\"_ as allowed call set. This revert happens during the verification of the permissions of the address for its allowed calls. A `from` address is not allowed to have 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff in its list of `AddressPermissions:AllowedCalls:<address>`, as this allows any STANDARD:ADDRESS:FUNCTION. This is equivalent to granting the SUPER permission and should never be valid.",
        "params": {
          "from": "The controller address that has _\"any allowed calls\"_ whitelisted set."
        }
      }
    ],
    "KeyManagerCannotBeSetAsExtensionForLSP20Functions()": [
      {
        "details": "Reverts when the address of the Key Manager is being set as extensions for lsp20 functions"
      }
    ],
    "LSP6BatchExcessiveValueSent(uint256,uint256)": [
      {
        "details": "This error occurs when there was too much funds sent to the batch functions `execute(uint256[],bytes[])` or `executeRelayCall(bytes[],uint256[],uint256[],bytes[])` to cover the sum of all the values forwarded on Reverts to avoid the KeyManager to holds some remaining funds sent to the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[]) This error occurs when `msg.value` is more than the sum of all the values being forwarded on each payloads (`values[]` parameter from the batch functions above)."
      }
    ],
    "LSP6BatchInsufficientValueSent(uint256,uint256)": [
      {
        "details": "This error occurs when there was not enough funds sent to the batch functions `execute(uint256[],bytes[])` or `executeRelayCall(bytes[],uint256[],uint256[],bytes[])` to cover the sum of all the values forwarded on each payloads (`values[]` parameter from the batch functions above). This mean that `msg.value` is less than the sum of all the values being forwarded on each payloads (`values[]` parameters).",
        "params": {
          "msgValue": "The amount of native tokens sent to the batch functions `execute(uint256[],bytes[])` or `executeRelayCall(bytes[],uint256[],uint256[],bytes[])`.",
          "totalValues": "The sum of all the values forwarded on each payloads (`values[]` parameter from the batch functions above)."
        }
      }
    ],
    "NoCallsAllowed(address)": [
      {
        "details": "Reverts when the `from` address has no `AllowedCalls` set and cannot interact with any address using the linked {target}.",
        "params": {
          "from": "The address that has no AllowedCalls."
        }
      }
    ],
    "NoERC725YDataKeysAllowed(address)": [
      {
        "details": "Reverts when the `from` address has no AllowedERC725YDataKeys set and cannot set any ERC725Y data key on the ERC725Y storage of the linked {target}.",
        "params": {
          "from": "The address that has no `AllowedERC725YDataKeys` set."
        }
      }
    ],
    "NoPermissionsSet(address)": [
      {
        "details": "Reverts when address `from` does not have any permissions set on the account linked to this Key Manager",
        "params": {
          "from": "the address that does not have permissions"
        }
      }
    ],
    "NotAllowedCall(address,address,bytes4)": [
      {
        "details": "Reverts when `from` is not authorised to call the `execute(uint256,address,uint256,bytes)` function because of a not allowed callType, address, standard or function.",
        "params": {
          "from": "The controller that tried to call the `execute(uint256,address,uint256,bytes)` function.",
          "selector": "If `to` is a contract, the bytes4 selector of the function that `from` is trying to call. If no function is called (_e.g: a native token transfer_), selector = `0x00000000`",
          "to": "The address of an EOA or contract that `from` tried to call using the linked {target}"
        }
      }
    ],
    "NotAllowedERC725YDataKey(address,bytes32)": [
      {
        "details": "Reverts when address `from` is not authorised to set the key `disallowedKey` on the linked {target}.",
        "params": {
          "disallowedKey": "A bytes32 data key that `from` is not authorised to set on the ERC725Y storage of the linked {target}.",
          "from": "address The controller that tried to `setData` on the linked {target}."
        }
      }
    ],
    "NotAuthorised(address,string)": [
      {
        "details": "Reverts when address `from` is not authorised and does not have `permission` on the linked {target}",
        "params": {
          "from": "address The address that was not authorised.",
          "permission": "permission The permission required (_e.g: `SETDATA`, `CALL`, `TRANSFERVALUE`)"
        }
      }
    ],
    "NotRecognisedPermissionKey(bytes32)": [
      {
        "details": "Reverts when `dataKey` is a `bytes32` value that does not adhere to any of the permission data keys defined by the LSP6 standard",
        "params": {
          "dataKey": "The dataKey that does not match any of the standard LSP6 permission data keys."
        }
      }
    ],
    "RelayCallBeforeStartTime()": [
      {
        "details": "Reverts when the relay call is cannot yet bet executed. This mean that the starting timestamp provided to {executeRelayCall} function is bigger than the current timestamp."
      }
    ],
    "RelayCallExpired()": [
      {
        "details": "Reverts when the period to execute the relay call has expired."
      }
    ]
  },
  "kind": "dev",
  "methods": {
    "constructor": {
      "details": "Deploy a Key Manager and set the `target_` address in the contract storage, making this Key Manager linked to this `target_` contract.",
      "params": {
        "target_": "The address of the contract to control and forward calldata payloads to."
      }
    },
    "execute(bytes)": {
      "custom:events": "{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.",
      "details": "Execute A `payload` on the linked {target} contract after having verified the permissions associated with the function being run. The `payload` MUST be a valid abi-encoded function call of one of the functions present in the linked {target}, otherwise the call will fail. The linked {target} will return some data on successful execution, or revert on failure.",
      "params": {
        "payload": "The abi-encoded function call to execute on the linked {target}."
      },
      "returns": {
        "_0": "The abi-decoded data returned by the function called on the linked {target}."
      }
    },
    "executeBatch(uint256[],bytes[])": {
      "custom:events": "{PermissionsVerified} event for each permissions related to each `payload` that have been verified successfully.",
      "details": "Same as {execute} but execute a batch of payloads (abi-encoded function calls) in a single transaction.",
      "params": {
        "payloads": "An array of abi-encoded function calls to execute successively on the linked {target}.",
        "values": "An array of amount of native tokens to be transferred for each `payload`."
      },
      "returns": {
        "_0": "An array of abi-decoded data returned by the functions called on the linked {target}."
      }
    },
    "executeRelayCall(bytes,uint256,uint256,bytes)": {
      "custom:events": "{PermissionsVerified} event when the permissions related to `payload` have been verified successfully.",
      "custom:hint": "If you are looking to learn how to sign and execute relay transactions via the Key Manager, see our Javascript step by step guide [_\"Execute Relay Transactions\"_](../../../learn/expert-guides/key-manager/execute-relay-transactions.md). See the LSP6 Standard page for more details on how to [generate a valid signature for Execute Relay Call](../../../standards/universal-profile/lsp6-key-manager.md#how-to-sign-relay-transactions).",
      "details": "Allows any address (executor) to execute a payload (= abi-encoded function call), given they have a valid signature from a signer address and a valid `nonce` for this signer. The signature MUST be generated according to the signature format defined by the LSP25 standard. The signer that generated the `signature` MUST be a controller with some permissions on the linked {target}. The `payload` will be executed on the {target} contract once the LSP25 signature and the permissions of the signer have been verified.",
      "params": {
        "nonce": "The nonce of the address that signed the calldata (in a specific `_channel`), obtained via {getNonce}. Used to prevent replay attack.",
        "payload": "The abi-encoded function call to execute.",
        "signature": "A 65 bytes long signature for a meta transaction according to LSP25.",
        "validityTimestamps": "Two `uint128` timestamps concatenated together that describes when the relay transaction is valid \"from\" (left `uint128`) and \"until\" as a deadline (right `uint128`)."
      },
      "returns": {
        "_0": "The data being returned by the function executed."
      }
    },
    "executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])": {
      "custom:requirements": "- the length of `signatures`, `nonces`, `validityTimestamps`, `values` and `payloads` MUST be the same. - the value sent to this function (`msg.value`) MUST be equal to the sum of all `values` in the batch. There should not be any excess value sent to this function.",
      "details": "Same as {executeRelayCall} but execute a batch of signed calldata payloads (abi-encoded function calls) in a single transaction. The `signatures` can be from multiple controllers, not necessarely the same controller, as long as each of these controllers that signed have the right permissions related to the calldata `payload` they signed.",
      "params": {
        "nonces": "An array of nonces of the addresses that signed the calldata payloads (in specific channels). Obtained via {getNonce}. Used to prevent replay attack.",
        "payloads": "An array of abi-encoded function calls to be executed successively.",
        "signatures": "An array of 65 bytes long signatures for meta transactions according to LSP25.",
        "validityTimestamps": "An array of two `uint128` concatenated timestamps that describe when the relay transaction is valid \"from\" (left `uint128`) and \"until\" (right `uint128`).",
        "values": "An array of amount of native tokens to be transferred for each calldata `payload`."
      },
      "returns": {
        "_0": "An array of abi-decoded data returned by the functions executed."
      }
    },
    "getNonce(address,uint128)": {
      "custom:hint": "A signer can choose its channel number arbitrarily. The recommended practice is to: - use `channelId == 0` for transactions for which the ordering of execution matters.abi _Example: you have two transactions A and B, and transaction A must be executed first and complete successfully before transaction B should be executed)._ - use any other `channelId` number for transactions that you want to be order independant (out-of-order execution, execution _\"in parallel\"_). _Example: you have two transactions A and B. You want transaction B to be executed a) without having to wait for transaction A to complete, or b) regardless if transaction A completed successfully or not.",
      "details": "Get the nonce for a specific `from` address that can be used for signing relay transactions via {executeRelayCall}.",
      "params": {
        "channelId": "The channel id that the signer wants to use for executing the transaction.",
        "from": "The address of the signer of the transaction."
      },
      "returns": {
        "_0": "The current nonce on a specific `channelId`."
      }
    },
    "isValidSignature(bytes32,bytes)": {
      "custom:warning": "This function does not enforce by default the inclusion of the address of this contract in the signature digest. It is recommended that protocols or applications using this contract include the targeted address (= this contract) in the data to sign. To ensure that a signature is valid for a specific LSP6KeyManager and prevent signatures from the same EOA to be replayed across different LSP6KeyManager.",
      "details": "Checks if a signature was signed by a controller that has the permission `SIGN`. If the signer is a controller with the permission `SIGN`, it will return the ERC1271 success value.",
      "params": {
        "hash": "Hash of the data to be signed",
        "signature": "Signature byte array associated with _data"
      },
      "returns": {
        "returnedStatus": "`0x1626ba7e` on success, or `0xffffffff` on failure."
      }
    },
    "lsp20VerifyCall(address,address,address,uint256,bytes)": {
      "custom:hint": "This function can call by any other address than the {`target`}. This allows to verify permissions in a _\"read-only\"_ manner. Anyone can call this function to verify if the `caller` has the right permissions to perform the abi-encoded function call `data` on the {`target`} contract (while sending `msgValue` alongside the call). If the permissions have been verified successfully and `caller` is authorized, one of the following two LSP20 success value will be returned:  - `0x1a238000`: LSP20 success value **without** post verification (last byte is `0x00`).  - `0x1a238001`: LSP20 success value **with** post-verification (last byte is `0x01`).",
      "params": {
        "callData": "The calldata sent by the caller to the msg.sender",
        "caller": "The address who called the function on the `target` contract.",
        "requestor": "The address that requested to make the call to `target`.",
        "target": "The address of the contract that implements the `LSP20CallVerification` interface.",
        "value": "The value sent by the caller to the function called on the msg.sender"
      },
      "returns": {
        "_0": "MUST return the first 3 bytes of `lsp20VerifyCall(address,uint256,bytes)` function selector if the call to the function is allowed, concatened with a byte that determines if the lsp20VerifyCallResult function should be called after the original function call. The byte that invoke the lsp20VerifyCallResult function is strictly `0x01`."
      }
    },
    "lsp20VerifyCallResult(bytes32,bytes)": {
      "params": {
        "callHash": "The keccak256 hash of the parameters of {lsp20VerifyCall} concatenated",
        "callResult": "The value result of the function called on the msg.sender"
      },
      "returns": {
        "_0": "MUST return the lsp20VerifyCallResult function selector if the call to the function is allowed"
      }
    },
    "supportsInterface(bytes4)": {
      "details": "See {IERC165-supportsInterface}."
    },
    "target()": {
      "details": "Get The address of the contract linked to this Key Manager.",
      "returns": {
        "_0": "The address of the linked contract"
      }
    }
  },
  "title": "Implementation of a contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage.",
  "version": 1
}