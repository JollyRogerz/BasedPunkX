{
  "errors": {
    "ERC725Y_DataKeysValuesEmptyArray()": [
      {
        "details": "Reverts when one of the array parameter provided to {setDataBatch} function is an empty array."
      }
    ],
    "ERC725Y_DataKeysValuesLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `datakeys` and `dataValues` array parameters provided when calling the {setDataBatch} function."
      }
    ],
    "ERC725Y_MsgValueDisallowed()": [
      {
        "details": "Reverts when sending value to the {setData} or {setDataBatch} function."
      }
    ],
    "InvalidExtensionAddress(bytes)": [
      {
        "details": "reverts when the bytes retrieved from the LSP17 data key is not a valid address (not 20 bytes)"
      }
    ],
    "InvalidFunctionSelector(bytes)": [
      {
        "details": "reverts when the contract is called with a function selector not valid (less than 4 bytes of data)"
      }
    ],
    "LSP4TokenNameNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed / initialized. The `LSP4TokenName` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor/initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP4TokenSymbolNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed / initialized. The `LSP4TokenSymbol` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor/initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP4TokenTypeNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenType` after the digital asset contract has been deployed / initialized. The `LSP4TokenType` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor / initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP8BatchCallFailed(uint256)": [
      {
        "details": "Reverts when a batch call failed."
      }
    ],
    "LSP8CannotSendToAddressZero()": [
      {
        "details": "Reverts when trying to send token to the zero address."
      }
    ],
    "LSP8CannotSendToSelf()": [
      {
        "details": "Reverts when specifying the same address for `from` and `to` in a token transfer."
      }
    ],
    "LSP8CannotUseAddressZeroAsOperator()": [
      {
        "details": "Reverts when trying to set the zero address as an operator."
      }
    ],
    "LSP8InvalidTransferBatch()": [
      {
        "details": "Reverts when the parameters used for `transferBatch` have different lengths."
      }
    ],
    "LSP8NonExistentTokenId(bytes32)": [
      {
        "details": "Reverts when `tokenId` has not been minted."
      }
    ],
    "LSP8NonExistingOperator(address,bytes32)": [
      {
        "details": "Reverts when `operator` is not an operator for the `tokenId`."
      }
    ],
    "LSP8NotTokenOperator(bytes32,address)": [
      {
        "details": "Reverts when `caller` is not an allowed operator for `tokenId`."
      }
    ],
    "LSP8NotTokenOwner(address,bytes32,address)": [
      {
        "details": "Reverts when `caller` is not the `tokenOwner` of the `tokenId`."
      }
    ],
    "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)": [
      {
        "details": "Reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool force` set as `false`."
      }
    ],
    "LSP8NotifyTokenReceiverIsEOA(address)": [
      {
        "details": "Reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool force` set as `false`."
      }
    ],
    "LSP8OperatorAlreadyAuthorized(address,bytes32)": [
      {
        "details": "Reverts when `operator` is already authorized for the `tokenId`."
      }
    ],
    "LSP8TokenContractCannotHoldValue()": [
      {
        "details": "Error occurs when sending native tokens to the LSP8 contract without sending any data. E.g. Sending value without passing a bytes4 function selector to call a LSP17 Extension."
      }
    ],
    "LSP8TokenIdAlreadyMinted(bytes32)": [
      {
        "details": "Reverts when `tokenId` has already been minted."
      }
    ],
    "LSP8TokenIdFormatNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP8TokenIdFormat` after the identifiable digital asset contract has been deployed. The `LSP8TokenIdFormat` data key is located inside the ERC725Y Data key-value store of the identifiable digital asset contract. It can be set only once inside the constructor/initializer when the identifiable digital asset contract is being deployed."
      }
    ],
    "LSP8TokenIdsDataEmptyArray()": [
      {
        "details": "Reverts when empty arrays is passed to the function"
      }
    ],
    "LSP8TokenIdsDataLengthMismatch()": [
      {
        "details": "Reverts when the length of the token IDs data arrays is not equal"
      }
    ],
    "LSP8TokenOwnerCannotBeOperator()": [
      {
        "details": "Reverts when trying to authorize or revoke the token's owner as an operator."
      }
    ],
    "NoExtensionFoundForFunctionSelector(bytes4)": [
      {
        "details": "reverts when there is no extension for the function selector being called with"
      }
    ],
    "OwnableCallerNotTheOwner(address)": [
      {
        "details": "Reverts when only the owner is allowed to call the function.",
        "params": {
          "callerAddress": "The address that tried to make the call."
        }
      }
    ],
    "OwnableCannotSetZeroAddressAsOwner()": [
      {
        "details": "Reverts when trying to set `address(0)` as the contract owner when deploying the contract, initializing it or transferring ownership of the contract."
      }
    ]
  },
  "kind": "dev",
  "methods": {
    "authorizeOperator(address,bytes32,bytes)": {
      "details": "Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard",
      "params": {
        "operator": "The address to authorize as an operator.",
        "operatorNotificationData": "The data to notify the operator about via LSP1.",
        "tokenId": "The token ID operator has access to."
      }
    },
    "balanceOf(address)": {
      "details": "Get the number of token IDs owned by `tokenOwner`.",
      "params": {
        "tokenOwner": "The address to query     *"
      },
      "returns": {
        "_0": "The total number of token IDs that `tokenOwner` owns."
      }
    },
    "batchCalls(bytes[])": {
      "custom:info": "It's not possible to send value along the functions call due to the use of `delegatecall`.",
      "details": "Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",
      "params": {
        "data": "An array of ABI encoded function calls to be called on the contract."
      },
      "returns": {
        "results": "An array of abi-encoded data returned by the functions executed."
      }
    },
    "constructor": {
      "params": {
        "lsp4TokenType_": "The type of token this digital asset contract represents (`0` = Token, `1` = NFT, `2` = Collection).",
        "lsp8TokenIdFormat_": "The format of tokenIds (= NFTs) that this contract will create.",
        "name_": "The name of the token.",
        "newOwner_": "The owner of the token contract.",
        "symbol_": "The symbol of the token."
      }
    },
    "getData(bytes32)": {
      "details": "Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",
      "params": {
        "dataKey": "The data key for which to retrieve the value."
      },
      "returns": {
        "dataValue": "The bytes value stored under the specified data key."
      }
    },
    "getDataBatch(bytes32[])": {
      "details": "Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",
      "params": {
        "dataKeys": "The array of keys which values to retrieve"
      },
      "returns": {
        "dataValues": "The array of data stored at multiple keys"
      }
    },
    "getDataBatchForTokenIds(bytes32[],bytes32[])": {
      "params": {
        "dataKeys": "An array of data keys corresponding to the token IDs.",
        "tokenIds": "An array of token IDs."
      },
      "returns": {
        "dataValues": "An array of data values for each pair of `tokenId` and `dataKey`."
      }
    },
    "getDataForTokenId(bytes32,bytes32)": {
      "params": {
        "dataKey": "The key for the data to retrieve.",
        "tokenId": "The unique identifier for a token."
      },
      "returns": {
        "dataValue": "The data value associated with the given `tokenId` and `dataKey`."
      }
    },
    "getOperatorsOf(bytes32)": {
      "details": "Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.",
      "params": {
        "tokenId": "The token ID to get the operators for."
      },
      "returns": {
        "_0": "An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."
      }
    },
    "isOperatorFor(address,bytes32)": {
      "details": "Returns whether `operator` address is an operator for a given `tokenId`.",
      "params": {
        "operator": "The address to query operator status for.",
        "tokenId": "The token ID to check if `operator` is allowed to operate on."
      },
      "returns": {
        "_0": "`true` if `operator` is an operator for `tokenId`, `false` otherwise."
      }
    },
    "mint(address,bytes32,bool,bytes)": {
      "details": "Public {_mint} function only callable by the {owner}.",
      "params": {
        "data": "Any addition data to be sent alongside the minting.",
        "force": "Set to `false` to ensure that you are minting for a recipient that implements LSP1, `false` otherwise for forcing the minting.",
        "to": "The address that will receive the minted `tokenId`.",
        "tokenId": "The tokenId to mint."
      }
    },
    "owner()": {
      "details": "Returns the address of the current owner."
    },
    "renounceOwnership()": {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "revokeOperator(address,bytes32,bool,bytes)": {
      "details": "Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.",
      "params": {
        "notify": "Boolean indicating whether to notify the operator or not",
        "operator": "The address to revoke as an operator.",
        "operatorNotificationData": "The data to notify the operator about via LSP1.",
        "tokenId": "The tokenId `operator` is revoked from operating on."
      }
    },
    "setData(bytes32,bytes)": {
      "custom:events": "{DataChanged} event.",
      "custom:requirements": "- SHOULD only be callable by the {owner}.",
      "custom:warning": "**Note for developers:** despite the fact that this function is set as `payable`, if the function is not intended to receive value (= native tokens), **an additional check should be implemented to ensure that `msg.value` sent was equal to 0**.",
      "details": "Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",
      "params": {
        "dataKey": "The data key for which to set a new value.",
        "dataValue": "The new bytes value to set."
      }
    },
    "setDataBatch(bytes32[],bytes[])": {
      "custom:events": "{DataChanged} event **for each data key/value pair set**.",
      "custom:requirements": "- SHOULD only be callable by the {owner} of the contract.",
      "custom:warning": "**Note for developers:** despite the fact that this function is set as `payable`, if the function is not intended to receive value (= native tokens), **an additional check should be implemented to ensure that `msg.value` sent was equal to 0**.",
      "details": "Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",
      "params": {
        "dataKeys": "An array of data keys to set bytes values for.",
        "dataValues": "An array of bytes values to set for each `dataKeys`."
      }
    },
    "setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])": {
      "params": {
        "dataKeys": "An array of data keys corresponding to the token IDs.",
        "dataValues": "An array of values to set for the given data keys.",
        "tokenIds": "An array of token IDs."
      }
    },
    "setDataForTokenId(bytes32,bytes32,bytes)": {
      "params": {
        "dataKey": "The key for the data to set.",
        "dataValue": "The value to set for the given data key.",
        "tokenId": "The unique identifier for a token."
      }
    },
    "supportsInterface(bytes4)": {
      "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
    },
    "tokenIdsOf(address)": {
      "details": "Returns the list of token IDs that the `tokenOwner` address owns.",
      "params": {
        "tokenOwner": "The address that we want to get the list of token IDs for."
      },
      "returns": {
        "_0": "An array of `bytes32[] tokenIds` owned by `tokenOwner`."
      }
    },
    "tokenOwnerOf(bytes32)": {
      "details": "Returns the list of `tokenIds` for the `tokenOwner` address.",
      "params": {
        "tokenId": "tokenOwner The address to query owned tokens"
      },
      "returns": {
        "_0": "The owner address of the given `tokenId`."
      }
    },
    "totalSupply()": {
      "details": "Returns the number of existing tokens that have been minted in this contract.",
      "returns": {
        "_0": "The number of existing tokens."
      }
    },
    "transfer(address,address,bytes32,bool,bytes)": {
      "details": "Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.",
      "params": {
        "data": "Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",
        "force": "When set to `true`, the `to` address CAN be any addres. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",
        "from": "The address that owns the given `tokenId`.",
        "to": "The address that will receive the `tokenId`.",
        "tokenId": "The token ID to transfer."
      }
    },
    "transferBatch(address[],address[],bytes32[],bool[],bytes[])": {
      "details": "Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.",
      "params": {
        "data": "Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.",
        "force": "When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.",
        "from": "An array of sending addresses.",
        "to": "An array of recipient addresses.",
        "tokenId": "An array of token IDs to transfer."
      }
    },
    "transferOwnership(address)": {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    }
  },
  "title": "LSP8IdentifiableDigitalAsset deployable preset contract with a public {mint} function callable only by the contract {owner}.",
  "version": 1
}