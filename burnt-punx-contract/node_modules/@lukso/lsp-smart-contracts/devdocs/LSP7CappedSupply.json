{
  "details": "LSP7 token extension to add a max token supply cap.",
  "errors": {
    "ERC725Y_DataKeysValuesEmptyArray()": [
      {
        "details": "Reverts when one of the array parameter provided to {setDataBatch} function is an empty array."
      }
    ],
    "ERC725Y_DataKeysValuesLengthMismatch()": [
      {
        "details": "Reverts when there is not the same number of elements in the `datakeys` and `dataValues` array parameters provided when calling the {setDataBatch} function."
      }
    ],
    "ERC725Y_MsgValueDisallowed()": [
      {
        "details": "Reverts when sending value to the {setData} or {setDataBatch} function."
      }
    ],
    "InvalidExtensionAddress(bytes)": [
      {
        "details": "reverts when the bytes retrieved from the LSP17 data key is not a valid address (not 20 bytes)"
      }
    ],
    "InvalidFunctionSelector(bytes)": [
      {
        "details": "reverts when the contract is called with a function selector not valid (less than 4 bytes of data)"
      }
    ],
    "LSP4TokenNameNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed / initialized. The `LSP4TokenName` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor/initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP4TokenSymbolNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed / initialized. The `LSP4TokenSymbol` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor/initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP4TokenTypeNotEditable()": [
      {
        "details": "Reverts when trying to edit the data key `LSP4TokenType` after the digital asset contract has been deployed / initialized. The `LSP4TokenType` data key is located inside the ERC725Y data key-value store of the digital asset contract. It can be set only once inside the constructor / initializer when the digital asset contract is being deployed / initialized."
      }
    ],
    "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)": [
      {
        "details": "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`."
      }
    ],
    "LSP7AmountExceedsBalance(uint256,address,uint256)": [
      {
        "details": "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`."
      }
    ],
    "LSP7BatchCallFailed(uint256)": [
      {
        "details": "Reverts when a batch call failed."
      }
    ],
    "LSP7CannotSendToSelf()": [
      {
        "details": "reverts when specifying the same address for `from` or `to` in a token transfer."
      }
    ],
    "LSP7CannotSendWithAddressZero()": [
      {
        "details": "reverts when trying to: - mint tokens to the zero address. - burn tokens from the zero address. - transfer tokens from or to the zero address."
      }
    ],
    "LSP7CannotUseAddressZeroAsOperator()": [
      {
        "details": "reverts when trying to set the zero address as an operator."
      }
    ],
    "LSP7CappedSupplyCannotMintOverCap()": [
      {
        "details": "Reverts when trying to mint tokens but the {totalSupply} has reached the maximum {tokenSupplyCap}."
      }
    ],
    "LSP7CappedSupplyRequired()": [
      {
        "details": "Reverts when setting `0` for the {tokenSupplyCap}. The max token supply MUST be set to a number greater than 0."
      }
    ],
    "LSP7DecreasedAllowanceBelowZero()": [
      {
        "details": "Reverts when trying to decrease an operator's allowance to more than its current allowance."
      }
    ],
    "LSP7InvalidTransferBatch()": [
      {
        "details": "reverts when the array parameters used in {transferBatch} have different lengths."
      }
    ],
    "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)": [
      {
        "details": "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool force` set as `false`."
      }
    ],
    "LSP7NotifyTokenReceiverIsEOA(address)": [
      {
        "details": "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool force` set as `false`."
      }
    ],
    "LSP7TokenContractCannotHoldValue()": [
      {
        "details": "Error occurs when sending native tokens to the LSP7 contract without sending any data. E.g. Sending value without passing a bytes4 function selector to call a LSP17 Extension."
      }
    ],
    "LSP7TokenOwnerCannotBeOperator()": [
      {
        "details": "reverts when trying to authorize or revoke the token's owner as an operator."
      }
    ],
    "NoExtensionFoundForFunctionSelector(bytes4)": [
      {
        "details": "reverts when there is no extension for the function selector being called with"
      }
    ],
    "OperatorAllowanceCannotBeIncreasedFromZero(address)": [
      {
        "details": "Reverts when token owner call {increaseAllowance} for an operator that does not have any allowance"
      }
    ],
    "OwnableCallerNotTheOwner(address)": [
      {
        "details": "Reverts when only the owner is allowed to call the function.",
        "params": {
          "callerAddress": "The address that tried to make the call."
        }
      }
    ],
    "OwnableCannotSetZeroAddressAsOwner()": [
      {
        "details": "Reverts when trying to set `address(0)` as the contract owner when deploying the contract, initializing it or transferring ownership of the contract."
      }
    ]
  },
  "kind": "dev",
  "methods": {
    "authorizeOperator(address,uint256,bytes)": {
      "custom:danger": "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. either call {revokeOperator} first, and then re-call {authorizeOperator} with the new amount.     2. or use the non-standard functions {increaseAllowance} or {decreaseAllowance}. For more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
      "details": "Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}. Notify the operator based on the LSP1-UniversalReceiver standard",
      "params": {
        "amount": "The allowance amount of tokens operator has access to.",
        "operator": "The address to authorize as an operator.",
        "operatorNotificationData": "The data to notify the operator about via LSP1."
      }
    },
    "authorizedAmountFor(address,address)": {
      "details": "Get the amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners.",
      "params": {
        "operator": "The operator's address to query the authorized amount for.",
        "tokenOwner": "The token owner that `operator` has allowance on."
      },
      "returns": {
        "_0": "The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance."
      }
    },
    "balanceOf(address)": {
      "details": "Get the number of tokens owned by `tokenOwner`. If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided by 1e18 to get a better picture of the actual balance of the `tokenOwner`. _Example:_ ``` balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens ```",
      "params": {
        "tokenOwner": "The address of the token holder to query the balance for."
      },
      "returns": {
        "_0": "The amount of tokens owned by `tokenOwner`."
      }
    },
    "batchCalls(bytes[])": {
      "custom:info": "It's not possible to send value along the functions call due to the use of `delegatecall`.",
      "details": "Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.",
      "params": {
        "data": "An array of ABI encoded function calls to be called on the contract."
      },
      "returns": {
        "results": "An array of abi-encoded data returned by the functions executed."
      }
    },
    "constructor": {
      "custom:requirements": "- `tokenSupplyCap_` MUST NOT be 0.",
      "details": "Deploy a `LSP7CappedSupply` token contract and set the maximum token supply token cap up to which it is not possible to mint more tokens.",
      "params": {
        "tokenSupplyCap_": "The maximum token supply."
      }
    },
    "decimals()": {
      "details": "Returns the number of decimals used to get its user representation. If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in the `constructor`, the decimals returned wiil be `0`. Otherwise `18` is the common value.",
      "returns": {
        "_0": "the number of decimals. If `0` is returned, the asset is non-divisible."
      }
    },
    "decreaseAllowance(address,uint256,bytes)": {
      "details": "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",
      "params": {
        "operator": "The operator to decrease allowance for `msg.sender`",
        "subtractedAmount": "The amount to decrease by in the operator's allowance."
      }
    },
    "getData(bytes32)": {
      "details": "Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.",
      "params": {
        "dataKey": "The data key for which to retrieve the value."
      },
      "returns": {
        "dataValue": "The bytes value stored under the specified data key."
      }
    },
    "getDataBatch(bytes32[])": {
      "details": "Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.",
      "params": {
        "dataKeys": "The array of keys which values to retrieve"
      },
      "returns": {
        "dataValues": "The array of data stored at multiple keys"
      }
    },
    "getOperatorsOf(address)": {
      "details": "Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.",
      "params": {
        "tokenOwner": "The token owner to get the operators for."
      },
      "returns": {
        "_0": "An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`."
      }
    },
    "increaseAllowance(address,uint256,bytes)": {
      "details": "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard",
      "params": {
        "addedAmount": "The additional amount to add on top of the current operator's allowance",
        "operator": "The operator to increase the allowance for `msg.sender`"
      }
    },
    "owner()": {
      "details": "Returns the address of the current owner."
    },
    "renounceOwnership()": {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "revokeOperator(address,bool,bytes)": {
      "details": "Removes the `operator` address as an operator of callers tokens, disallowing it to send any amount of tokens on behalf of the token owner (the caller of the function `msg.sender`). See also {authorizedAmountFor}.",
      "params": {
        "notify": "Boolean indicating whether to notify the operator or not.",
        "operator": "The address to revoke as an operator.",
        "operatorNotificationData": "The data to notify the operator about via LSP1."
      }
    },
    "setData(bytes32,bytes)": {
      "custom:events": "{DataChanged} event.",
      "custom:requirements": "- SHOULD only be callable by the {owner}.",
      "custom:warning": "**Note for developers:** despite the fact that this function is set as `payable`, if the function is not intended to receive value (= native tokens), **an additional check should be implemented to ensure that `msg.value` sent was equal to 0**.",
      "details": "Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.",
      "params": {
        "dataKey": "The data key for which to set a new value.",
        "dataValue": "The new bytes value to set."
      }
    },
    "setDataBatch(bytes32[],bytes[])": {
      "custom:events": "{DataChanged} event **for each data key/value pair set**.",
      "custom:requirements": "- SHOULD only be callable by the {owner} of the contract.",
      "custom:warning": "**Note for developers:** despite the fact that this function is set as `payable`, if the function is not intended to receive value (= native tokens), **an additional check should be implemented to ensure that `msg.value` sent was equal to 0**.",
      "details": "Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.",
      "params": {
        "dataKeys": "An array of data keys to set bytes values for.",
        "dataValues": "An array of bytes values to set for each `dataKeys`."
      }
    },
    "supportsInterface(bytes4)": {
      "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
    },
    "tokenSupplyCap()": {
      "details": "Get the maximum number of tokens that can exist to circulate. Once {totalSupply} reaches reaches {totalSuuplyCap}, it is not possible to mint more tokens.",
      "returns": {
        "_0": "The maximum number of tokens that can exist in the contract."
      }
    },
    "totalSupply()": {
      "details": "Returns the number of existing tokens that have been minted in this contract.",
      "returns": {
        "_0": "The number of existing tokens."
      }
    },
    "transfer(address,address,uint256,bool,bytes)": {
      "details": "Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function. If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer has been completed (See {authorizedAmountFor}).",
      "params": {
        "amount": "The amount of tokens to transfer.",
        "data": "Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.",
        "force": "When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",
        "from": "The sender address.",
        "to": "The recipient address."
      }
    },
    "transferBatch(address[],address[],uint256[],bool[],bytes[])": {
      "details": "Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.",
      "params": {
        "amount": "An array of amount of tokens to transfer for each `from -> to` transfer.",
        "data": "An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
        "force": "For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.",
        "from": "An array of sending addresses.",
        "to": "An array of receiving addresses."
      }
    },
    "transferOwnership(address)": {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    }
  },
  "version": 1
}